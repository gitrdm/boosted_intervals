---
title: "Working with Unit-Aware Intervals"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with Unit-Aware Intervals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(boostedintervals)
library(units)
```

## Motivation

Intervals capture measurement uncertainty by storing lower and upper bounds.
`boostedintervals` wires Boost.Interval into R while preserving `units`
metadata, so physical dimensions remain attached throughout your
calculations.

## Constructing unit-aware intervals

Use `units_interval()` to build interval vectors. Bounds can be supplied as plain
numerics with an explicit unit, or as `units` vectors.

```{r}
length_interval <- units_interval(0, 5, unit = "m")
length_interval

acceleration <- units_interval(
  set_units(c(9.5, 9.7), "m/s^2"),
  set_units(c(9.8, 9.81), "m/s^2")
)
acceleration
```

The helper `as_units_interval()` coercion wraps scalars, numeric vectors, and
existing `units` objects:

```{r}
as_units_interval(3, unit = "cm")
as_units_interval(set_units(1:3, "s"))
```

## Arithmetic and unit propagation

Standard arithmetic operators reuse Boost's interval arithmetic while keeping
unit algebra intact.

```{r}
width_a <- units_interval(set_units(2, "m"), set_units(3, "m"))
width_b <- units_interval(set_units(4, "m"), set_units(5, "m"))

sum_interval <- width_a + width_b
sum_interval
units(sum_interval$lower)

time_span <- units_interval(1, 2, unit = "s")
speed_interval <- sum_interval / time_span
speed_interval
units(speed_interval$lower)
```

Unary transformations preserve unit semantics as well. Absolute value keeps
the original units while square roots require squared quantities and return
the principal root expressed in the corresponding base unit. Integer powers are
available through `^` as long as the exponent is whole and, for negative powers,
the interval does not span zero.

```{r}
abs(width_a - width_b)

area_interval <- units_interval(set_units(25, "m^2"), set_units(36, "m^2"))
sqrt(area_interval)

volume_interval <- width_a ^ 3
volume_interval
units(volume_interval$lower)

angles <- units_interval(0, pi / 6, unit = "rad")
sin(angles)
cos(angles)
tan(angles)

sin(convert_units(angles, "degree"))

direction <- units_interval(-0.5, 0.5, unit = "1")
asin(direction)
acos(direction)
atan(direction)

growth <- units_interval(0, 0.25, unit = "1")
exp(growth)
expm1(growth)
log(units_interval(1, 5, unit = "1"))
log1p(units_interval(0, 0.5, unit = "1"))
log2(units_interval(1, 8, unit = "1"))
tanh(growth)
asinh(units_interval(-0.2, 0.2, unit = "1"))

exp2(growth)
pow2(units_interval(-1, 2, unit = "1"))
sqrt1pm1(units_interval(-0.3, 0.3, unit = "1"))
hypot(width_a, width_b)
```

Exponentials, hyperbolic functions, and logarithms require dimensionless
intervals. That includes the expanded family of helpers shown above:
`expm1()`, `log1p()`, and `log2()` alongside their `exp()`, `log()`, and
`log10()` counterparts, as well as the base-2 variants `exp2()`/`pow2()` and
the numerically stable `sqrt1pm1()`. The Euclidean norm can be computed via
`hypot()` when combining multiple length intervals. Trigonometric functions
accept angles expressed in
radians or any units convertible to radians, converting behind the scenes
before evaluating the function. Inverse trigonometric functions consume
dimensionless inputs but return angles in radians. If inputs carry
incompatible units (for instance, meters), an informative error is raised to
help catch inconsistent analyses early.

Comparison operators recycle operands, align units, and return logical vectors.

```{r}
width_a <= convert_units(width_b, "cm")
width_a == width_b
```

## Interval predicates and set operations

Containment queries accept points, `units` vectors, or other intervals.

```{r}
contains(sum_interval, set_units(6, "m"))
contains(sum_interval, sum_interval / 2)
```

Use `overlaps()` to test intersections and `interval_intersection()` /
`interval_union()` to build new intervals.

```{r}
other_width <- units_interval(set_units(3, "m"), set_units(6, "m"))

overlaps(sum_interval, other_width)
intersection <- interval_intersection(sum_interval, other_width)
intersection

hull <- interval_union(sum_interval, other_width)
hull
```

When you need sentinel values, `empty_interval()` and `whole_interval()`
construct canonical extremes while retaining unit metadata. Superset helpers
mirror the subset predicates and `is_whole()` identifies fully unbounded
intervals.

```{r}
empty_like_sum <- empty_interval(like = sum_interval)
whole_like_sum <- whole_interval(like = sum_interval)

is_empty(empty_like_sum)
is_whole(whole_like_sum)
is_superset(whole_like_sum, sum_interval)
```

## Visualization-ready summaries

Utilities such as `width()`, `midpoint()`, `median()`, `radius()`, `norm()`,
`mag()`, `mig()`, and `distance()` return `units` vectors that can be fed directly into
plotting pipelines or summary tables, while diagnostics like `zero_in()` and
`is_whole()` surface common Boost predicates. When you need interval
transformations, `bisect()` splits each interval at its Boost median, and
`inflate()` expands bounds by absolute or relative margins without losing unit
metadata.

```{r}
width(sum_interval)
midpoint(other_width)
median(other_width)

radius(sum_interval)
norm(direction)
mag(direction)
mig(direction)
distance(width_a, width_b)
zero_in(direction)

pow_interval(units_interval(set_units(1, "m^2"), set_units(9, "m^2")), 0.5)
nth_root(units_interval(set_units(1, "m^4"), set_units(16, "m^4")), 4)
pow1p(direction, 3)

bisect(other_width)
inflate(sum_interval, absolute = set_units(0.1, "m"))
hull(sum_interval, other_width, empty_interval(unit = "m"), na.rm = TRUE)
```

## Directed rounding and policy controls

Boost exposes fine-grained rounding controls to adjust intervals conservatively
or aggressively at the floating-point lattice level. `boostedintervals` surfaces
these helpers directly:

```{r}
interval <- units_interval(set_units(1, "m"), set_units(2, "m"))

# Expand or contract endpoints by individual ULP steps
successor(interval)
predecessor(interval)
round_outward(interval)
round_inward(interval)

# `next_interval()` shifts both bounds in tandem
next_interval(interval)
prior_interval(interval)
```

You can temporarily control Boost's rounding and checking policies using the
`with_*()` helpers. They ensure the previous state is restored automatically and
work well inside pipelines or tests:

```{r}
get_rounding_mode()
with_rounding_mode("upward", {
  successor(0)
})

get_checking_mode()
with_checking_mode("warning", {
  successor(Inf)
})
```

## Next steps

The interval building blocks shown here integrate smoothly with tidy workflows:
wrap results in data frames, summarize with dplyr, or visualise with ggplot2
using the lower/upper bounds. For more advanced scenarios—such as repeated
operations over large vectors—consider caching intervals and reusing them across
calculations to minimize repeated unit conversions.
